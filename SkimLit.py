# -*- coding: utf-8 -*-
"""SkimLit(NLP).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12VH3EtdSCbZey5WtNTYKN6ri2BTwxVFO

## SKIMLIT : The purpose of this project is to make a NLP model to make medical abstracts easier to read.

Replicating PubMed 200k RCT

# Get data

Since we are replicating the paper PubMed 200K RCT , let's download the dataset they had used

https://github.com/Franck-Dernoncourt/pubmed-rct
"""

!git clone https://github.com/Franck-Dernoncourt/pubmed-rct
!ls pubmed-rct

# Check what files are present in PubMed_20k ( since smaller dataset so faster experimentations)
!ls pubmed-rct/PubMed_20k_RCT_numbers_replaced_with_at_sign/

# Train is the training data , test is the testing data , dev is the vlaidation data

# start our experiments using 20k dataset with numbers replaced by sign
import os

data_dir = "/content/pubmed-rct/PubMed_20k_RCT_numbers_replaced_with_at_sign/"

filenames = [data_dir + filenames for filenames in os.listdir(data_dir)]
filenames

"""# Preprocess data

Now become one with it
- visualize visualize visualizr

So lets write a function to read in lines of the target txt
"""

# write a function to read in lines from a file
def get_lines(filename):

  """
  Reads filename ( a text filename) and returns. the text lines as a list

  Args:
  filename: a string containing target filepath.

  returns:
  A list of strings with one string per line from the target filename
  """

  with open(filename, "r") as f:
    return f.readlines()

"""readlines function returns list of lines"""

train_lines = get_lines(data_dir + "train.txt")
train_lines[:20]

len(train_lines)

"""# We want our data to look something like this

```

[{'line_number': 0,
  'target': 'BACKGROUND',
  'text': 'Emotional eating is associated with overeating and the development of obesity',
  'total_lines': 11}]

```
"""

!nvidia-smi -L

def preprocess_text_with_line_numbers(filename):

  """
  Returns a list of dictionaries of abstract line data.

  Takes in filename, read the lines , sorts the lines ,
  extracting things like the target label , the text of
  the sentence, how many sentences are in the current
  abstract and what sentence number the target line is

  """
  input_lines = get_lines(filename) # get all lines from filename

  abstract_lines = " "

  abstract_sample = [] # create an empty list of abstracts



  # Loop through each line in the target file

  for line in input_lines:
    if line.startswith("###"):  # To check if this is an ID line
      abstract_id = line
      abstract_lines = "" # reset the abstract string if the line is an ID line

    elif line.isspace():   # checks for new line /n we are using isspace but it still checks for /n as a space
      abstract_line_split = abstract_lines.splitlines() # split abstract into different lines


      # Iterate through each line in a single abstract and count them at the same time

      for abstract_line_number, abstract_line in enumerate(abstract_line_split):
        line_data = {}
        target_text_split = abstract_line.split("\t") # split target label from text
        line_data["target"] = target_text_split[0] # get target label
        line_data["text"] = target_text_split[1].lower() # get target text and lower it
        line_data["line_number"] = abstract_line_number
        line_data["total_lines"] = len(abstract_line_split) - 1. # how many total lines are there in target abstract?

        abstract_sample.append(line_data) # add line data to abstract samples list


    else:  # if the above conditions are not fullfilled the line contains a labelled sentence
      abstract_lines += line

  return abstract_sample

# Commented out IPython magic to ensure Python compatibility.
# # Get data from file and preprocess it
# 
# %%time
# train_samples = preprocess_text_with_line_numbers(data_dir + "train.txt")
# val_samples = preprocess_text_with_line_numbers(data_dir + "dev.txt")
# test_samples = preprocess_text_with_line_numbers(data_dir + "test.txt")
# 
# len(train_samples ), len(val_samples) , len(test_samples)

# check the first abstract of our training data

train_samples[:14]

len(val_samples)

"""# Now that our data is in the form of list of dictionaries , how about we turn it into a DataFrame and further visualize it"""

import pandas as pd

train_df = pd.DataFrame(train_samples)
val_df = pd.DataFrame(val_samples)
test_df = pd.DataFrame(test_samples)

train_df.head(14)

# Distribution of labels in the training dataframe

train_df.target.value_counts()

val_df.target.value_counts()

test_df.target.value_counts()

# let's check the length of different sentences in dataframe

train_df.total_lines.plot.hist()

"""# Mostly of length between 5 and 18 at avg

# Get lists of sentences
"""

# Convert abstract text lines to list

train_sentences = train_df["text"].to_list()
val_sentences = val_df["text"].to_list()
test_sentences = test_df["text"].to_list()

train_sentences[:10], val_sentences[:10], test_sentences[:10]

"""## Make Numerical Labels(ML models require numeric data but also numeric labels)"""

# One hot encode labels

from sklearn.preprocessing import OneHotEncoder
one_hot_encoder = OneHotEncoder(sparse = False )
train_labels_one_hot = one_hot_encoder.fit_transform(train_df["target"].to_numpy().reshape(-1,1))
val_labels_one_hot = one_hot_encoder.transform(val_df["target"].to_numpy().reshape(-1,1))
test_labels_one_hot = one_hot_encoder.transform(test_df["target"].to_numpy().reshape(-1,1))

import tensorflow as tf # keep sparse to False because turning it into tensor is giving us error that tensor is not compatible with sparse array

tf.constant(train_labels_one_hot)

"""## Label encode labels"""

# Extract labels ("target" columns) and encode them into integers
from sklearn.preprocessing import LabelEncoder

label_encoder  = LabelEncoder()

train_labels_encoded = label_encoder.fit_transform(train_df["target"].to_numpy().reshape(-1,1))
val_labels_encoded = label_encoder.transform(val_df["target"].to_numpy().reshape(-1,1))
test_labels_encoded = label_encoder.transform(test_df["target"].to_numpy().reshape(-1,1))

train_labels_encoded

# Get Class Names and number of classes from LabelEncoder instance

num_classes = len(label_encoder.classes_)
class_names = label_encoder.classes_
num_classes , class_names

"""## Starting a series of modelling experiments

As usual we are going to be trying out bunch of different models and seeing which one works best.

And as always we are going to start with a baseline (TF-IDF) Multinomial Naive Bayes Classifier

#Model 0 : Starting with Baseline
"""

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.naive_bayes import MultinomialNB
from sklearn.pipeline import Pipeline

# create a pipeline

model_0 = Pipeline([
    ("tfidf" , TfidfVectorizer()),
    ("clf", MultinomialNB()),

])

# Fit the pipeline to the training data

model_0.fit(X=train_sentences,
            y = train_labels_encoded)

# Evaluate on validation data

model_0.score(val_sentences,
              val_labels_encoded)

# make predictions using baseline model

baseline_preds = model_0.predict(val_sentences)
baseline_preds

val_labels_encoded

"""### Download helper function script

I have created a helper function that I would import (accuracy , precision , recall , F1) , let's downlaod helper function.

"""

!wget https://raw.githubusercontent.com/mrdbourke/tensorflow-deep-learning/main/extras/helper_functions.py

from helper_functions import calculate_results

baseline_results = calculate_results(val_labels_encoded,baseline_preds)

baseline_results

#How long is each sentence on average
import numpy as np
sent_lens = [len(sentence.split()) for sentence in train_sentences]
sum_avg = np.mean(sent_lens)
sum_avg

import matplotlib.pyplot as plt

plt.hist(sent_lens, bins = 40);

# how long of a sentence length covers 95% of our examples
# this helps us in deciding what length of sentences cover major part of our data(95 percentile)
# We are doing this so that there are not much 0's for our sentences when we use textvectorizer

output_seq_len = int(np.percentile(sent_lens , 95))
output_seq_len

"""# Create Text Vectorizer

We want to make a layer which maps our text from words to number
"""

# how many words are in our vocab ( taken from the reasearch paper we read) 68k

max_tokens = 68000

# Create a text vectorizer

from tensorflow.keras.layers.experimental.preprocessing import TextVectorization

text_vectorizer = TextVectorization(max_tokens = max_tokens,
                                    output_sequence_length = output_seq_len,
                                    pad_to_max_tokens = True,
                                    )

# Adapt text vectorizer to training sentences

text_vectorizer.adapt(train_sentences)

vocabulary = text_vectorizer.get_vocabulary()

vocabulary[:10]

rct_20k_length = len(vocabulary)

rct_20k_length

# Test out text vectorizer on random sentences
import random
target_sentence = random.choice(train_sentences)
random_sentence_vectorized = text_vectorizer(target_sentence)
random_sentence_vectorized , target_sentence

# get the config of our text vectorizer

text_vectorizer.get_config()

"""
# Create custom text embedding"""

# Create token embedding layer
from tensorflow.keras.layers import Embedding

# Create an embedding layer


token_embed = Embedding(input_dim = rct_20k_length, # length of vocabulary
                          output_dim = 128,
                        mask_zero = True, # use masking to handle variable sequence length , 0's will be computed in a effecient way by tf
                        name = "token_embedding")

# Show example embedding

print(target_sentence)

print(f"After vectorization \n {text_vectorizer(target_sentence)}\n")
vectorized_text = text_vectorizer(target_sentence)
print(f"After embedding \n{token_embed(vectorized_text)}")

"""## Creating datasets (making sure our data loads as fast as possible)

We are going to setup our data to load as fast as possible with the Tensorflow tf.data API
"""

# Turn our data into TensorFlow Datasets

train_dataset = tf.data.Dataset.from_tensor_slices((train_sentences, train_labels_one_hot))
valid_dataset = tf.data.Dataset.from_tensor_slices((val_sentences, val_labels_one_hot))
test_dataset = tf.data.Dataset.from_tensor_slices((test_sentences, test_labels_one_hot))
train_dataset

# Take the tensorslice datasets and convert them into prefetched datsets

train_dataset = train_dataset.batch(32).prefetch(tf.data.AUTOTUNE) # automatically prefetches as many as possible
valid_dataset = valid_dataset.batch(32).prefetch(tf.data.AUTOTUNE)
test_dataset = test_dataset.batch(32).prefetch(tf.data.AUTOTUNE)

train_dataset

## Model 1 : Conv1D with token embedding

from tensorflow.keras import layers
input = layers.Input(shape=(1,), dtype = tf.string, name = "input_layer")
text_vector_layer = text_vectorizer(input)
embeded_layers = token_embed(text_vector_layer)
x = layers.Conv1D(64 , kernel_size = 5 , padding= "same", activation ="relu")(embeded_layers)
x = layers.GlobalAveragePooling1D()(x)
output = layers.Dense(num_classes , activation ="softmax")(x)
model_1  = tf.keras.Model(input , output)


# Compile

model_1.compile(loss = "categorical_crossentropy",
                optimizer = tf.keras.optimizers.Adam(),
                metrics = ["accuracy"])



history_model_1 = model_1.fit(train_dataset,
                        steps_per_epoch = int(0.1 * len(train_dataset)),
                        epochs = 4,
                        validation_data = valid_dataset,
                        validation_steps = int(0.1*len(valid_dataset))
                        )

model_1.evaluate(valid_dataset)

#make predictions (our model predicts probabilities for each class)

model_1_pred_probs = model_1.predict(valid_dataset)
model_1_pred_probs, model_1_pred_probs.shape

# Convert pred probs to classes

model_1_pred_probs = tf.argmax(model_1_pred_probs, axis = 1)
model_1_pred_probs

class_names

# Calculate model_1 results
model_1_results = calculate_results(val_labels_encoded,
                                    model_1_pred_probs)

model_1_results

baseline_results

"""## Model 2 : Feature Extraction with pretrained model embedding

Now lets use pretrained word embeddings from Tensorflow Hub , more specially the universal sentence encoder


The paper originally used glove embedding however we are going to stick we later create universal sentence encoder (USE) pretrained embeddings.

"""

# Download pretrained TensorFlow HUB USE

import tensorflow_hub as hub
tf_hub_embedding_layer = hub.KerasLayer("https://tfhub.dev/google/universal-sentence-encoder/4",
                                        trainable = False,# feature extraction not fine tuning
                                        name = "universal_sentence_encoder")

# Test out the pretrained embedding on a random sentence
random_train_sentence = random.choice(train_sentences)
print(random_train_sentence)
use_embedding_sentence = tf_hub_embedding_layer([random_train_sentence])
use_embedding_sentence

len(use_embedding_sentence[0]) # this is 512 because universal sentence encoder has this as a feature to give 512

# model 2 ( input -> USE(encoder) -> Dense(decoder) -> Result)

inputs = layers.Input(shape=() ,dtype = tf.string,  name = "input_layer")

use_embedding_layer = tf_hub_embedding_layer(inputs)

x = layers.Dense(64 , activation = "relu")(use_embedding_layer)

output = layers.Dense(5, activation = "softmax")(x)

model_2 = tf.keras.Model(inputs,output)

model_2.compile(loss = "categorical_crossentropy",
                optimizer = tf.keras.optimizers.Adam(),
                metrics = ["accuracy"])

history_model_2 = model_2.fit(train_dataset,
                              steps_per_epoch = int(0.1 * len(train_dataset)),
                              epochs = 4,
                              validation_data = valid_dataset,
                              validation_steps =int(0.1 * len(valid_dataset)))

# Evaluate on whole validation dataset

model_2.evaluate(valid_dataset)

# predicitons

model_2_pred_probs = model_2.predict(valid_dataset)
model_2_pred_probs

model_2_pred_probs = tf.argmax(model_2_pred_probs, axis = 1)

model_2_pred_probs

model_2_results = calculate_results(val_labels_encoded , model_2_pred_probs)

model_2_results

baseline_results

"""## Model 3 : Conv1D with character embedding

The paper which we are replicating used a combination of token and character level embeddings

Previously we have used token level embedding but we'll need to do similar steps for character if we want to use char-level embedding

# Create Character Level Embedding

To use character level embedding we should first format the text into character level so that character level embedding can be used.

" I love Tensorflow" -> " I,,l,o,v,e T,e,n,s,o,r,f,l,o,w"
"""

train_sentences[:5]

# Make function to split sentences into characters

def split_chars(text):
  return " ".join(list(text))

# Test splitting non-character-level sequence into characters

split_chars(random_train_sentence)

" ".join(list(train_sentences[0]))

# Split sequence-level data split into character level data splits

train_chars = [split_chars(sentence)for sentence in train_sentences]
val_chars = [split_chars(sentence)for sentence in val_sentences]
test_chars = [split_chars(sentence)for sentence in test_sentences]
train_chars[:5]
val_chars[:5]

# WHat is average character length

char_lens = [len(char) for char in train_sentences]
char_lens_mean = np.mean(char_lens)

char_lens_mean

# CHeck the distribution of our at a character level
import matplotlib.pyplot as plt
plt.hist(char_lens, bins=7);

# Find what character length covers 95% of sequences
output_seq_char_lens = int(np.percentile(char_lens, 95))
output_seq_char_lens

"""# Max Tokens

Max Tokens in character level embedding would be all the characters available rather than just words in the vocabulary that we used for textvectorization at word level


We should get all keyboard keys
"""

# Get all keyboard characters

 import string
 alphabet = string.ascii_lowercase + string.digits + string.punctuation
 alphabet

alphabet_lens = [len(i) for i in alphabet]
len(alphabet_lens)

# Create char-level token vecotrization instance

NUM_CHAR_TOKEN = len(alphabet) + 2 # one for space and one for OOV (out of vocabulary ["UNK"])
char_vectorizer = TextVectorization(max_tokens = NUM_CHAR_TOKEN,
                                    output_sequence_length = output_seq_char_lens,
                                    pad_to_max_tokens = True,
                                    name= "char_vectorizer")

# Adapt to char_vectorizer to the training character
char_vectorizer.adapt(train_chars)

#Check char vocab stats

char_vocab = char_vectorizer.get_vocabulary()
print(char_vocab)
print(len(char_vocab))
print(f"Most common chars used {char_vocab[:5]}")

# Test our character vectorizert
random_train_chars = random.choice(train_chars)
print(f"Charified text: \n {random_train_chars}")
print(f"length of random train chars: {len(random_train_chars.split())}")
print(f"vectorized random train chars {char_vectorizer([random_train_chars])}")

# make character level embedding


from tensorflow.keras.layers import Embedding

char_embedding = Embedding(input_dim = len(char_vocab),
                           output_dim = 25, # 25 is used in the reasearch paper
                           mask_zero = True,
                           name = "char_embed")

# test out character embedding

print(f" before: \n {random_train_chars} \n")
print(f"after embed {char_embedding(char_vectorizer([random_train_chars]))}")
print(f"its shape {char_embedding(char_vectorizer([random_train_chars])).shape}")

# Shape means 1 sequence ( that is one sentence ) is vectorized in 290 size of characters and theneach token is further embedded in 25

# model 2.1 Conv2D with globalpooling


from tensorflow.keras import layers
input = layers.Input(shape=(1,), dtype = tf.string, name = "input_layer")
text_vector_layer = text_vectorizer(input)
embeded_layers = token_embed(text_vector_layer)
x = layers.Conv1D(64 , kernel_size = 5 , padding= "same", activation ="relu")(embeded_layers)
x = layers.GlobalMaxPooling1D()(x)
output = layers.Dense(num_classes , activation ="softmax")(x)
model_1_1  = tf.keras.Model(input , output)


# Compile

model_1_1.compile(loss = "categorical_crossentropy",
                optimizer = tf.keras.optimizers.Adam(),
                metrics = ["accuracy"])

history_model_1_1 = model_1_1.fit(train_dataset,
                        steps_per_epoch = int(0.1 * len(train_dataset)),
                        epochs = 4,
                        validation_data = valid_dataset,
                        validation_steps = int(0.1*len(valid_dataset))
                        )

# Model 3 : Conv1D with char embeddings

inputs = tf.keras.Input(shape=(1,), dtype = tf.string , name="input_name")

char_vectors= char_vectorizer(inputs)

char_embeds = char_embedding(char_vectors)

x = layers.Conv1D(64,kernel_size =5 , padding="same" ,activation = "relu")(char_embeds)
x = layers.GlobalMaxPooling1D()(x)
output = layers.Dense(num_classes, activation = "softmax")(x)
model_3 = tf.keras.Model(inputs,output)

model_3.compile(loss = "categorical_crossentropy",
                optimizer = tf.keras.optimizers.Adam(),
                metrics = ["accuracy"])

model_3.summary()

# create char level datasets

train_char_dataset = tf.data.Dataset.from_tensor_slices((train_chars,train_labels_one_hot)).batch(32).prefetch(tf.data.AUTOTUNE)
val_char_dataset = tf.data.Dataset.from_tensor_slices((val_chars,val_labels_one_hot)).batch(32).prefetch(tf.data.AUTOTUNE)
test_char_dataset = tf.data.Dataset.from_tensor_slices((test_chars,test_labels_one_hot)).batch(32).prefetch(tf.data.AUTOTUNE)

# Fit the model on chars only

history_model_3 = model_3.fit(train_char_dataset,
                              steps_per_epoch = int(0.1 *len(train_char_dataset)),
                              epochs = 4,
                              validation_data = val_char_dataset,
                              validation_steps = int(0.1 * len(val_char_dataset)))

# make prediction with model 3

model_3_pred_probs = model_3.predict(val_char_dataset)

model_3_pred_probs

# Convert these predictions

model_3_pred_probs = tf.argmax(model_3_pred_probs,axis=1)

model_3_results = calculate_results(val_labels_encoded,model_3_pred_probs)

model_1_1_pred_probs = model_1_1.predict(valid_dataset)

model_1_1_pred_probs

model_1_1_pred_probs = tf.argmax(model_1_1_pred_probs,axis =1)

model_1_1_results = calculate_results(val_labels_encoded, model_1_1_pred_probs)

val_labels_encoded

model_1_1_pred_probs

"""# Model 4 : Combine pretrained token embedding + characters embeddings (Hybrid embeddings)

1. Create a token level embedding model (similar to `model-1`)
2. Create a char-level embedding model (similar `model-3` with a small modification)
3. Combine 1 & 2 with a concatenate (`layers.Concatenate)
4. Build a series of output layers on top of 3 similar to figure 1 and section 4.2 of the paper
5. COnstruct a model that takes token and character-level embeddings as input and produces sequence label probabilities as output
"""

#1. Setup token inputs/model

token_inputs = layers.Input(shape=[], dtype = tf.string, name = "token_input") # shape is [empty] because
token_embeddings = tf_hub_embedding_layer(token_inputs)
token_outputs = layers.Dense(128, activation="relu")(token_embeddings)
token_model = tf.keras.Model(token_inputs,token_outputs)

#2. Setup chars input/model

char_input = layers.Input(shape=(1,), dtype = tf.string, name="char_input")
char_vectors = char_vectorizer(char_input)
char_embeds = char_embedding(char_vectors)
char_bi_lstm = layers.Bidirectional(layers.LSTM(24))(char_embeds) #bi-LSTM shown in figure 1 of our research paper
char_model = tf.keras.Model(char_input, # in paper 50 is used , as they go l-r and r-l so we used 24 it means it will be 48
                            char_bi_lstm)

#3. Concatenate token and char inputs (create hybrid token embedding)
token_char_concat = layers.Concatenate(name = "token_char_hybrid")([token_model.output,char_model.output])

#4. Create output layers - adding in dropout , discussed in section 4.2 of research paper

combined_dropout = layers.Dropout(0.5)(token_char_concat)
combined_dense = layers.Dense(128,activation = "relu")(combined_dropout)
final_dropout = layers.Dropout(0.5)(combined_dense)
output_layer = layers.Dense(num_classes, activation="softmax")(final_dropout)

#5. Construct model with char and token

model_4 = tf.keras.Model(inputs=[token_model.input, char_model.input],
                         outputs= output_layer ,
                         name= "model_4_token_and_char_embedding")

# Get a summary of our model
model_4.summary()

# Plot hybrid token and character model

from keras.utils import plot_model

plot_model(model_4 , show_shapes = True)

# Compile model

model_4.compile(loss = "categorical_crossentropy",
                optimizer = tf.keras.optimizers.Adam(),
                metrics = ["accuracy"])

"""# As we are using multiple data sources we need to use tf.data.dataset even more efficiently , so we would need to know about could it do it.

# Combining token and character into a tf.data  dataset
"""

# Combine chars and tokens into a dataset

train_char_token_data = tf.data.Dataset.from_tensor_slices((train_sentences, train_chars)) # make data
train_char_token_label = tf.data.Dataset.from_tensor_slices((train_labels_one_hot)) # make labels
train_char_token_dataset = tf.data.Dataset.zip((train_char_token_data,train_char_token_label)) # combine data and labels

# batch and prefetch

train_char_token_dataset = train_char_token_dataset.batch(32).prefetch(tf.data.AUTOTUNE)

# Repeat the above work for validation

val_char_token_data = tf.data.Dataset.from_tensor_slices((val_sentences, val_chars)) # make data
val_char_token_label = tf.data.Dataset.from_tensor_slices((val_labels_one_hot)) # make labels
val_char_token_dataset = tf.data.Dataset.zip((val_char_token_data,val_char_token_label)) # combine data and labels

# batch and prefetch

val_char_token_dataset = val_char_token_dataset.batch(32).prefetch(tf.data.AUTOTUNE)

# Check out our training char and token embedding dataset
train_char_token_dataset,  val_char_token_dataset

"""# Fitting our model on token and char level embeddings"""

# model 4 fit

history_model_4 = model_4.fit(train_char_token_dataset,
                              epochs = 4,
                              steps_per_epoch = int(0.1 * len(train_char_token_dataset)),
                              validation_data = val_char_token_dataset,
                              validation_steps = int(0.1 * len(val_char_token_dataset)))

model_4.evaluate(val_char_token_dataset)

# make predictions

model_4_pred_probs = model_4.predict(val_char_token_dataset)

model_4_pred_probs

model_4_pred_probs = tf.argmax(model_4_pred_probs , axis = 1)

model_4_results = calculate_results(val_labels_encoded, model_4_pred_probs)

model_4_results

# Model_4_1 using custom token embeddings

token_inputs = layers.Input(shape=(1,), dtype = tf.string , name = "token_input")
token_vect = text_vectorizer(token_inputs)
token_embe = token_embed(token_vect)
x = layers.Conv1D(64 , kernel_size = 5 , padding= "same", activation ="relu")(embeded_layers)
x = layers.GlobalMaxPooling1D()(x)
output = layers.Dense(num_classes , activation ="softmax")(x)
token_model  = tf.keras.Model(input , output)


char_input = layers.Input(shape=(1,), dtype = tf.string, name="char_input")
char_vectors = char_vectorizer(char_input)
char_embeds = char_embedding(char_vectors)
char_bi_lstm = layers.Bidirectional(layers.LSTM(24))(char_embeds) #bi-LSTM shown in figure 1 of our research paper
char_model = tf.keras.Model(char_input, # in paper 50 is used , as they go l-r and r-l so we used 24 it means it will be 48
                            char_bi_lstm)

#3. Concatenate token and char inputs (create hybrid token embedding)
token_char_concat = layers.Concatenate(name = "token_char_hybrid")([token_model.output,char_model.output])

#4. Create output layers - adding in dropout , discussed in section 4.2 of research paper

combined_dropout = layers.Dropout(0.5)(token_char_concat)
combined_dense = layers.Dense(128,activation = "relu")(combined_dropout)
final_dropout = layers.Dropout(0.5)(combined_dense)
output_layer = layers.Dense(num_classes, activation="softmax")(final_dropout)

#5. Construct model with char and token

model_4_1 = tf.keras.Model(inputs=[token_model.input, char_model.input],
                         outputs= output_layer ,
                         name= "model_4_token_and_char_embedding")

model_4_1.compile(loss = "categorical_crossentropy",
                  optimizer = tf.keras.optimizers.Adam(),
                  metrics = ["accuracy"])

history_model_4_1 = model_4_1.fit(train_char_token_dataset,
                              epochs = 4,
                              steps_per_epoch = int(0.1 * len(train_char_token_dataset)),
                              validation_data = val_char_token_dataset,
                              validation_steps = int(0.1 * len(val_char_token_dataset)))

model_4_1.evaluate(val_char_token_dataset)

"""# Model 5: Transfer learning with pretrained token embeddings + character Embedding + Positional Embeddings

# **NOTE** : Any engineered features used to train a model needs to be available at test time. In our case Line numbers and total lines are available.

#Create positional embedding
"""

plt.hist(train_df["line_number"])

# How many different line numbers are there

percentiles = np.percentile(train_df["line_number"],95)
plt.hist(percentiles);

train_df["line_number"].value_counts()

"""# Use tensorflow for one hot encoding for line_number
We are one-hot encoding so that our model doesnt think that our line number 2 is twice as large as line number 1
"""

train_line_numbers_one_hot = tf.one_hot(train_df["line_number"].to_numpy(), depth = 15)
val_line_numbers_one_hot = tf.one_hot(val_df["line_number"].to_numpy(), depth =15)
test_line_numbers_one_hot = tf.one_hot(test_df["line_number"].to_numpy(), depth = 15)
train_line_numbers_one_hot[:40], train_line_numbers_one_hot.shape

train_df.head()

train_df["total_lines"].value_counts()

train_df.total_lines.plot.hist()

np.percentile(train_df["total_lines"],95)

# use tensorflow to create one_hot_encoding for total lines feature
train_total_lines_one_hot = tf.one_hot(train_df["total_lines"].to_numpy() ,depth = 20)
val_total_lines_one_hot = tf.one_hot(val_df["total_lines"].to_numpy(), depth =20)

train_total_lines_one_hot[:40]

"""### Building a tribid embedding model

1. Create a token-level model
2. Create a character-level model
3. Create a model for the line number feature
4. Create model for total lines feature
5. Combine the outputs of 1 & 2 using tf.keras.layers.Concatenate
6. Combine the outputs of 3,4 ,5 using tf.keras.layers.Concatenate
7. Create an output layer to accept the tribeded embedding and output label possibilities
8. Combine the inputs of 1 ,2 ,3 ,4 and the outputs of 7 into tf.keras.Model
"""

#1 . Token inputs
token_inputs = layers.Input(shape=[], dtype= "string" , name= "token_inputs")
token_embeddings = tf_hub_embedding_layer(token_inputs)
token_outputs = layers.Dense(128, activation = "relu")(token_embeddings)
token_model = tf.keras.Model(inputs = token_inputs,
                             outputs = token_outputs)

# 2. Char inputs
char_inputs = layers.Input(shape=[1,],dtype = "string", name = "char_inputs")
char_vectors = char_vectorizer(char_inputs)
char_embeddings = char_embedding(char_vectors)
char_bi_lstm = layers.Bidirectional(layers.LSTM(24))(char_embeddings)
char_model = tf.keras.Model(inputs = char_inputs,
                            outputs = char_bi_lstm)

#3. Line number model
line_numbers_inputs = layers.Input(shape=[15,],dtype= tf.float32,  name="line_numbers_inputs")
line_numbers_outputs = layers.Dense(32,activation = "relu")(line_numbers_inputs)
line_numbers_model = tf.keras.Model(inputs = line_numbers_inputs,
                                    outputs = line_numbers_outputs)

#4. Total lines model
total_lines_inputs = layers.Input(shape=[20,],dtype = tf.float32,  name="total_lines_inputs")
total_line_outputs = layers.Dense(32, activation= "relu")(total_lines_inputs)
total_lines_model = tf.keras.Model(inputs = total_lines_inputs,
                                   outputs = total_line_outputs)

#5. Combine token and char embeddings into a hybrid embeddings

combined_embeddings = layers.Concatenate(name = "char_token_hybrid_embeddings")([token_model.output,
                                                                                 char_model.output])
x = layers.Dense(256,activation="relu")(combined_embeddings)
x = layers.Dropout(0.5)(x)

#6. Combine positional with char and token embeddings

tribrid_embeddings = layers.Concatenate(name = "tribrid_embeddings")([line_numbers_model.output,
                                                                      total_lines_model.output,
                                                                      x])

#7. Create output layer

output_layer = layers.Dense(5, activation = "softmax", name="output_layer")(tribrid_embeddings)

#8 Put together model with all kinds of inputs

model_5 = tf.keras.Model(inputs = [token_model.input,
                         char_model.input,
                         line_numbers_model.input,
                         total_lines_model.input],
                         outputs = output_layer,
                         name = "tribrid_embedding_model")

model_5.summary()

from keras.utils import plot_model

plot_model(model_5)

"""# What is label smoothing

For example if our model gets too confident on a single class (e.g its prediction probability is very high) it may get stuck on that class and may not learn about other classes

Really Confident : [0.0 , 0.0, 0.0, 1, 0.0 , 0.0]

What label smoothing does is it assigns some of the value from the high confident class to other classes inturn hopefully improving generalization.
[0.01 , 0.01 , 0.01 , 0.95, 0.01 , 0.01]

"""

# Compile model_5


model_5.compile(loss = tf.keras.losses.CategoricalCrossentropy(label_smoothing=0.2),
                optimizer = tf.keras.optimizers.Adam(),
                metrics =["accuracy"])

"""### Create tribrid embedding datasets using tf.data

"""

# Create training and validation datasets ( with all four kinds on inputs)

train_char_token_pos_data = tf.data.Dataset.from_tensor_slices((train_sentences,
                                                                train_chars,
                                                                train_line_numbers_one_hot,
                                                                train_total_lines_one_hot))

train_char_token_pos_labels = tf.data.Dataset.from_tensor_slices(train_labels_one_hot)
train_char_token_pos_dataset = tf.data.Dataset.zip((train_char_token_pos_data, train_char_token_pos_labels))

train_char_token_pos_dataset = train_char_token_pos_dataset.batch(32).prefetch(tf.data.AUTOTUNE)

# DO the same for validation data

val_char_token_pos_data = tf.data.Dataset.from_tensor_slices((val_sentences,
                                                                val_chars,
                                                                val_line_numbers_one_hot,
                                                                val_total_lines_one_hot))

val_char_token_pos_labels = tf.data.Dataset.from_tensor_slices(val_labels_one_hot)
val_char_token_pos_dataset = tf.data.Dataset.zip((val_char_token_pos_data, val_char_token_pos_labels))

val_char_token_pos_dataset = val_char_token_pos_dataset.batch(32).prefetch(tf.data.AUTOTUNE)

# Check input shapes

train_char_token_pos_data, val_char_token_pos_data

"""### FITTING AND EVALUATING OUR TRIBRID MODEL"""

history_model_5 = model_5.fit(train_char_token_pos_dataset,
                              epochs = 3,
                              steps_per_epoch = int(0.3 * len(train_char_token_pos_dataset)),
                              validation_data = val_char_token_pos_dataset,
                              validation_steps = int(0.3 * len(val_char_token_pos_dataset)))

model_5.evaluate(val_char_token_pos_dataset)

#1 . Token inputs
token_inputs = layers.Input(shape=[], dtype= "string" , name= "token_inputs")
token_embeddings = tf_hub_embedding_layer(token_inputs)
token_outputs = layers.Dense(128, activation = "relu")(token_embeddings)
token_model = tf.keras.Model(inputs = token_inputs,
                             outputs = token_outputs)

# 2. Char inputs
char_inputs = layers.Input(shape=[1,],dtype = "string", name = "char_inputs")
char_vectors = char_vectorizer(char_inputs)
char_embeddings = char_embedding(char_vectors)
char_bi_lstm = layers.Bidirectional(layers.LSTM(24))(char_embeddings)
char_model = tf.keras.Model(inputs = char_inputs,
                            outputs = char_bi_lstm)

#3. Line number model
line_numbers_inputs = layers.Input(shape=[15,],dtype= tf.float32,  name="line_numbers_inputs")
line_numbers_outputs = layers.Dense(32,activation = "relu")(line_numbers_inputs)
line_numbers_model = tf.keras.Model(inputs = line_numbers_inputs,
                                    outputs = line_numbers_outputs)

#4. Total lines model
total_lines_inputs = layers.Input(shape=[20,],dtype = tf.float32,  name="total_lines_inputs")
total_line_outputs = layers.Dense(32, activation= "relu")(total_lines_inputs)
total_lines_model = tf.keras.Model(inputs = total_lines_inputs,
                                   outputs = total_line_outputs)

#5. Combine token and char embeddings into a hybrid embeddings

combined_embeddings = layers.Concatenate(name = "char_token_hybrid_embeddings")([token_model.output,
                                                                                 char_model.output])
x = layers.Dense(256,activation="relu")(combined_embeddings)
x = layers.Dropout(0.5)(x)

#6. Combine positional with char and token embeddings

tribrid_embeddings = layers.Concatenate(name = "tribrid_embeddings")([line_numbers_model.output,
                                                                      total_lines_model.output,
                                                                      x])

#7. Create output layer

output_layer = layers.Dense(5, activation = "softmax", name="output_layer")(tribrid_embeddings)

#8 Put together model with all kinds of inputs

model_5_1 = tf.keras.Model(inputs = [token_model.input,
                         char_model.input,
                         line_numbers_model.input,
                         total_lines_model.input],
                         outputs = output_layer,
                         name = "tribrid_embedding_model")

model_5_1.compile(loss = tf.keras.losses.CategoricalCrossentropy(label_smoothing=0.2),
                  optimizer = tf.keras.optimizers.SGD(),
                  metrics= ["accuracy"])

history_model_5_1 = model_5_1.fit(train_char_token_pos_dataset,
                                  epochs = 3,
                                  steps_per_epoch = int(0.1 * len(train_char_token_pos_dataset)),
                                  validation_data = val_char_token_pos_dataset,
                                  validation_steps = int(0.1 * len(val_char_token_pos_dataset)))

model_5_1.evaluate(val_char_token_pos_dataset)

# make predictions on tribrid model

model_5_pred_probs = model_5.predict(val_char_token_pos_dataset, verbose =1)
model_5_pred_probs

model_5_pred_probs = tf.argmax(model_5_pred_probs, axis =1)
model_5_pred_probs

model_5_results = calculate_results(val_labels_encoded, model_5_pred_probs)

model_5_results

model_4_results

model_3_results

model_2_results

model_1_results

model_1_1_results

# COmbine all model results into dataframe

all_model_results = pd.DataFrame({"model_0_baseline ": baseline_results,
                                  "model_1_" : model_1_results,
                                  "model_1_1(with global max pool)": model_1_1_results,
                                  "model_2": model_2_results,
                                  "model_3": model_3_results,
                                  "model_4": model_4_results,
                                  'model_5': model_5_results})
all_model_results = all_model_results.transpose()

all_model_results

all_model_results["accuracy"] = all_model_results["accuracy"]/100

all_model_results.plot(kind = "bar" , figsize=(10,7)).legend(bbox_to_anchor=(1.0,1.0))

# sort model by f1 score
all_model_results.sort_values("f1", ascending = True)["f1"].plot(kind = "bar", figsize=(10,7)).legend(bbox_to_anchor=(1.0,1.0))

model_5.save("skimlit_tribrid_model")

# load in out best performing model

loaded_model = tf.keras.models.load_model("skimlit_tribrid_model")

